/<(.+?)> –∑–∞–≥–æ–ª–æ–≤–æ–∫ –º–µ–Ω—è–µ–º –≤ –Ω–æ—É—Ç–µ –Ω–∞ #$1\n /
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>–†–µ–¥–∞–∫—Ç–æ—Ä —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏–∏</title>
    <style>
        /* –û–°–ù–û–í–ù–´–ï –°–¢–ò–õ–ò */
        body {
            font-family: 'Georgia', serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f9f9f9;
            line-height: 1.6;
        }

        /* –õ–ò–ü–ö–ò–ô –ê–£–î–ò–û–ü–õ–ï–ï–† –°–í–ï–†–•–£ */
        #audio-container {
            position: sticky;
            top: 0;
            z-index: 1000;
            background: white;
            padding: 15px;
            border-radius: 0 0 8px 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        /* –ü–ê–ù–ï–õ–¨ –£–ü–†–ê–í–õ–ï–ù–ò–Ø */
        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
            padding: 10px 0;
            margin-bottom: 20px;
        }

        /* –°–¢–ò–õ–¨ –°–ï–ì–ú–ï–ù–¢–û–í –¢–†–ê–ù–°–ö–†–ò–ü–¶–ò–ò */
        .segment {
            background: white;
            padding: 20px;
            margin: 15px 0;
            border-radius: 8px;
            border-left: 5px solid #3498db;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            cursor: pointer;
            transition: all 0.25s ease;
        }

        .segment:hover {
            background: #f8fdff;
            border-left-color: #2980b9;
            transform: translateX(4px);
        }

        .segment.active {
            background: #e8f4fc;
            border-left-color: #e74c3c;
            box-shadow: 0 4px 12px rgba(231, 76, 60, 0.15);
        }

        /* –†–ï–î–ê–ö–¢–ò–†–£–ï–ú–´–ï –¢–ê–ô–ú–ö–û–î–´ */
        .timestamp-editable {
            color: #2c3e50;
            font-family: 'Courier New', monospace;
            font-size: 0.95em;
            background: #ecf0f1;
            padding: 6px 12px;
            border-radius: 4px;
            margin-right: 10px;
            display: inline-block;
            border: 1px solid #d5dbdb;
            font-weight: 600;
            cursor: pointer;
            position: relative;
            user-select: none;
        }

        .timestamp-editable:hover {
            background: #d5dbdb;
        }

        .time-start, .time-end {
            padding: 2px 4px;
            border-radius: 2px;
            min-width: 40px;
            display: inline-block;
            transition: background 0.2s;
            outline: none;
        }

        .time-start:focus, .time-end:focus {
            background: white;
            outline: 2px solid #3498db;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.2);
        }

        /* –ö–ù–û–ü–ö–ò –£–ü–†–ê–í–õ–ï–ù–ò–Ø –°–ï–ì–ú–ï–ù–¢–û–ú */
        .segment-btn {
            background: transparent;
            border: none;
            padding: 4px 8px;
            margin: 0 2px;
            cursor: pointer;
            font-size: 14px;
            border-radius: 3px;
            vertical-align: middle;
            transition: all 0.2s;
        }

        .merge-btn {
            color: #27ae60;
        }

        .merge-btn:hover {
            background: #2ecc71;
            color: white;
        }

        .delete-btn {
            color: #e74c3c;
        }

        .delete-btn:hover {
            background: #e74c3c;
            color: white;
        }

        .split-btn {
            color: #9b59b6;
        }

        .split-btn:hover {
            background: #9b59b6;
            color: white;
        }

        /* –¢–ï–ö–°–¢ –î–õ–Ø –†–ï–î–ê–ö–¢–ò–†–û–í–ê–ù–ò–Ø */
        .text-content {
            display: inline-block;
            width: calc(100% - 240px);
            min-height: 28px;
            padding: 8px 12px;
            border: 1px dashed #ddd;
            border-radius: 4px;
            background: #fff;
            vertical-align: top;
            font-size: 16px;
            line-height: 1.5;
            margin-top: 10px;
        }

        .text-content:focus {
            outline: none;
            border-color: #3498db;
            border-style: solid;
            background: #fff;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.2);
        }

        /* –ö–ù–û–ü–ö–ò */
        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 10px 18px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 15px;
            font-weight: 500;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        button:hover {
            background: #2980b9;
            transform: translateY(-1px);
        }

        #saveBtn {
            background: #27ae60;
        }

        #saveBtn:hover {
            background: #219653;
        }

        /* –ì–†–£–ü–ü–ê –≠–ö–°–ü–û–†–¢–ê */
        .export-group {
            background: #fffde7;
            padding: 20px;
            border-radius: 8px;
            margin: 30px 0;
            border: 2px dashed #f1c40f;
        }

        /* –°–û–û–ë–©–ï–ù–ò–Ø */
        .error {
            color: #c0392b;
            padding: 12px;
            background: #ffebee;
            border-radius: 6px;
            margin: 10px 0;
            border-left: 4px solid #c0392b;
        }

        .success {
            color: #27ae60;
            padding: 12px;
            background: #eafaf1;
            border-radius: 6px;
            margin: 10px 0;
            border-left: 4px solid #27ae60;
        }

        /* –ü–û–õ–ï –î–õ–Ø –ó–ê–ì–†–£–ó–ö–ò */
        textarea {
            width: 100%;
            padding: 12px;
            font-family: 'Courier New', monospace;
            font-size: 15px;
            border: 1px solid #bdc3c7;
            border-radius: 6px;
            resize: vertical;
            line-height: 1.5;
        }

        textarea:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.2);
        }

        /* –ò–ù–§–û–†–ú–ê–¶–ò–Ø –û –§–û–†–ú–ê–¢–ï */
        .format-info {
            background: #e8f4f8;
            padding: 12px 15px;
            border-radius: 6px;
            margin: 15px 0;
            font-size: 0.9em;
            color: #2c3e50;
            border-left: 4px solid #3498db;
        }

        /* –ê–î–ê–ü–¢–ò–í–ù–û–°–¢–¨ */
        @media (max-width: 768px) {
            .timestamp-editable {
                display: block;
                margin-bottom: 10px;
                width: 100%;
            }
            .text-content {
                width: 100%;
                display: block;
                margin-top: 10px;
            }
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            button {
                width: 100%;
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <!-- –ö–û–ù–¢–ï–ô–ù–ï–† –ê–£–î–ò–û–ü–õ–ï–ï–†–ê -->
    <div id="audio-container">
        <audio id="audioPlayer" controls style="width: 100%;">
            <source src="" type="audio/mpeg">
            –í–∞—à –±—Ä–∞—É–∑–µ—Ä –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –∞—É–¥–∏–æ.
        </audio>
        <div style="margin-top: 10px;">
            <input type="file" id="audioUpload" accept="audio/*">
            <small>–ò–ª–∏ –ø–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –∞—É–¥–∏–æ—Ñ–∞–π–ª —Å—é–¥–∞</small>
        </div>
    </div>

    <!-- –ü–ê–ù–ï–õ–¨ –£–ü–†–ê–í–õ–ï–ù–ò–Ø -->
    <div class="controls">
        <button onclick="playFromStart()">‚ñ∂Ô∏è –° –Ω–∞—á–∞–ª–∞</button>
        <button onclick="pauseAudio()">‚è∏Ô∏è –ü–∞—É–∑–∞</button>
        <button onclick="playPrev()">‚èÆÔ∏è –ù–∞–∑–∞–¥</button>
        <button onclick="playNext()">‚è≠Ô∏è –í–ø–µ—Ä–µ–¥</button>
        <button onclick="playSelected()">üîä –í–æ—Å–ø—Ä–æ–∏–∑–≤–µ—Å—Ç–∏ –≤—ã–¥–µ–ª–µ–Ω–Ω–æ–µ</button>
        <button onclick="autoSplitLongSegments()" style="background: #9b59b6;">‚úÇÔ∏è –†–∞–∑–¥–µ–ª–∏—Ç—å –¥–ª–∏–Ω–Ω—ã–µ</button>
        <div style="margin-left: auto;">
            <label>–°–∫–æ—Ä–æ—Å—Ç—å: </label>
            <select id="playbackRate" onchange="changeSpeed()">
                <option value="0.5">0.5x</option>
                <option value="0.75">0.75x</option>
                <option value="1" selected>1x</option>
                <option value="1.25">1.25x</option>
                <option value="1.5">1.5x</option>
                <option value="2">2x</option>
            </select>
        </div>
    </div>

    <!-- –ò–ù–§–û–†–ú–ê–¶–ò–Ø –û –§–û–†–ú–ê–¢–ï -->
    <div class="format-info">
        <strong>üìå –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã:</strong><br>
        1. <code>00:00:00 ‚Äì 00:01:01</code> (–æ—Ç–¥–µ–ª—å–Ω–∞—è —Å—Ç—Ä–æ–∫–∞, –∑–∞—Ç–µ–º —Ç–µ–∫—Å—Ç)<br>
        2. <code>00:00:00 –¢–µ–∫—Å—Ç –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è –∑–¥–µ—Å—å...</code> (–≤—Ä–µ–º—è –∏ —Ç–µ–∫—Å—Ç –≤ –æ–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–µ)
    </div>

    <!-- –ó–ê–ì–†–£–ó–ö–ê –¢–†–ê–ù–°–ö–†–ò–ü–¶–ò–ò -->
    <div>
        <h3>üì• –ó–∞–≥—Ä—É–∑–∫–∞ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏–∏</h3>
        <textarea id="transcriptInput" style="height: 200px;"
                  placeholder="–í—Å—Ç–∞–≤—å—Ç–µ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏—é —Å —Ç–∞–π–º–∫–æ–¥–∞–º–∏. –ù–∞–ø—Ä–∏–º–µ—Ä:

00:00:00 ‚Äì 00:01:01
XX-–π –≤–µ–∫, –±—ã–ª —Å–æ–∑–¥–∞–Ω –ï–≤—Ä–µ–π—Å–∫–∏–π –ö–æ–Ω–≥—Ä–µ—Å—Å. –ò –≥–¥–µ-—Ç–æ –≤ 90-–µ –∏–ª–∏ 96-–µ –≥–æ–¥—ã...

00:01:02 ‚Äì 00:02:15
–ò –≤–æ—Ç –ø–æ–¥—Ö–æ–¥–∏–ª –•–• –≤–µ–∫. –ï–≤—Ä–µ–∏ —Å—á–∏—Ç–∞–ª–∏, —á—Ç–æ –ø–æ –ø—Ä–æ—Ä–æ—á–µ—Å—Ç–≤–∞–º...">
00:00:00 ‚Äì 00:00:05
–ú–∞—Ç—É—à–∫–∞, –±–ª–∞–≥–æ—Å–ª–æ–≤–∏—Ç–µ. –í–æ—Ç –≤–æ–ø—Ä–æ—Å —Ç–∞–∫–æ–π. –í–æ—Ç –µ—Å—Ç—å...

00:00:06 ‚Äì 00:00:34
–û—Ç—Ü—ã, –∫–æ—Ç–æ—Ä—ã–µ –≥–æ–≤–æ—Ä—è—Ç —á–∞–¥–∞–º –∏–ª–∏ –ø—Ä–æ—Å—Ç–æ –ø—Ä–∏—Ö–æ–∂–∞–Ω–∞–º...

00:00:34 ‚Äì 00:01:09
–ì–¥–µ –Ω–∞–π—Ç–∏ —Å–µ–±—è, –∫–∞–∫ —á–µ–ª–æ–≤–µ–∫—É –ø—Ä–∏—Å—Ç—É–ø–∞—Ç—å –∫ –ò–∏—Å—É—Å–æ–≤–æ–π –º–æ–ª–∏—Ç–≤–µ?...</textarea>
        <button onclick="parseAndRender()" style="margin-top: 10px; padding: 12px 24px;">üìã –ó–∞–≥—Ä—É–∑–∏—Ç—å —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏—é</button>
    </div>

    <!-- –û–¢–û–ë–†–ê–ñ–ï–ù–ò–ï –¢–†–ê–ù–°–ö–†–ò–ü–¶–ò–ò -->
    <h3>üìù –¢—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏—è</h3>
    <div id="status"></div>
    <div id="transcriptContainer"></div>

    <!-- –≠–ö–°–ü–û–†–¢ -->
    <div class="export-group">
        <h3>üíæ –≠–∫—Å–ø–æ—Ä—Ç</h3>
        <button id="saveBtn" onclick="exportJSON()">üì¶ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∫–∞–∫ JSON</button>
        <button onclick="exportMarkdown()" style="background: #9b59b6;">üìÑ –≠–∫—Å–ø–æ—Ä—Ç –≤ Markdown</button>
        <button onclick="exportOriginalFormat()" style="background: #e67e22;">üìù –≠–∫—Å–ø–æ—Ä—Ç –≤ –∏—Å—Ö–æ–¥–Ω–æ–º —Ñ–æ—Ä–º–∞—Ç–µ</button>
        <button onclick="exportSRT()" style="background: #16a085;">üé¨ –≠–∫—Å–ø–æ—Ä—Ç –≤ SRT (—Å—É–±—Ç–∏—Ç—Ä—ã)</button>
    </div>

    <script>
        // ========== –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï ==========
        let segments = [];
        let currentSegmentIndex = -1;
        const audio = document.getElementById('audioPlayer');
        const transcriptContainer = document.getElementById('transcriptContainer');
        const statusDiv = document.getElementById('status');

        // ========== –ü–ê–†–°–ï–† –¢–†–ê–ù–°–ö–†–ò–ü–¶–ò–ò ==========
        function parseTranscript(text) {
            const lines = text.split('\n');
            const parsedSegments = [];

            const formats = [
                { regex: /^(\d{1,2}):(\d{2}):(\d{2})\s*[‚Äì\-]\s*(\d{2}):(\d{2}):(\d{2})$/, isTimeRange: true },
                { regex: /^(\d{1,2}):(\d{2}):(\d{2})\s+(.+)$/, hasHours: true },
                { regex: /^(\d{1,2}):(\d{2})\s+(.+)$/, hasHours: false }
            ];

            let currentSegment = null;
            let nextLineIsText = false;

            for (let i = 0; i < lines.length; i++) {
                let line = lines[i].trim();
                if (!line) continue;

                let matchedFormat = null;
                let match = null;

                for (const format of formats) {
                    match = line.match(format.regex);
                    if (match) {
                        matchedFormat = format;
                        break;
                    }
                }

                if (matchedFormat) {
                    if (currentSegment) {
                        parsedSegments.push(currentSegment);
                        currentSegment = null;
                    }

                    if (matchedFormat.isTimeRange) {
                        const startTime = timeToSeconds(match[1], match[2], match[3]);
                        const endTime = timeToSeconds(match[4], match[5], match[6]);

                        nextLineIsText = true;
                        currentSegment = {
                            start: startTime,
                            end: endTime,
                            text: '',
                            originalLine: line
                        };
                    } else {
                        const hours = matchedFormat.hasHours ? parseInt(match[1]) : 0;
                        const minutes = matchedFormat.hasHours ? parseInt(match[2]) : parseInt(match[1]);
                        const seconds = matchedFormat.hasHours ? parseInt(match[3]) : parseInt(match[2]);
                        const segmentText = matchedFormat.hasHours ? match[4] : match[3];

                        const startTime = hours * 3600 + minutes * 60 + seconds;

                        currentSegment = {
                            start: startTime,
                            end: startTime + 30,
                            text: segmentText,
                            originalLine: line
                        };
                    }
                } else if (nextLineIsText && currentSegment) {
                    currentSegment.text = line;
                    nextLineIsText = false;
                } else if (currentSegment) {
                    if (currentSegment.text) {
                        currentSegment.text += ' ' + line;
                    } else {
                        currentSegment.text = line;
                    }
                }
            }

            if (currentSegment) {
                parsedSegments.push(currentSegment);
            }

            for (let i = 0; i < parsedSegments.length; i++) {
                if (i < parsedSegments.length - 1 && !parsedSegments[i].end) {
                    parsedSegments[i].end = parsedSegments[i + 1].start;
                } else if (!parsedSegments[i].end) {
                    parsedSegments[i].end = parsedSegments[i].start + 60;
                }
            }

            return parsedSegments;
        }

        function timeToSeconds(hours, minutes, seconds) {
            return parseInt(hours) * 3600 + parseInt(minutes) * 60 + parseInt(seconds);
        }

        function secondsToTime(seconds) {
            const hrs = Math.floor(seconds / 3600);
            const mins = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            return `${hrs.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        // ========== –û–¢–û–ë–†–ê–ñ–ï–ù–ò–ï –¢–†–ê–ù–°–ö–†–ò–ü–¶–ò–ò (–° –†–ï–î–ê–ö–¢–ò–†–£–ï–ú–´–ú–ò –¢–ê–ô–ú–ö–û–î–ê–ú–ò) ==========
        function renderTranscript() {
            transcriptContainer.innerHTML = '';

            if (segments.length === 0) {
                transcriptContainer.innerHTML = '<div class="error">‚ùå –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è. –ó–∞–≥—Ä—É–∑–∏—Ç–µ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏—é.</div>';
                return;
            }

            statusDiv.innerHTML = `<div class="success">‚úÖ –ó–∞–≥—Ä—É–∂–µ–Ω–æ ${segments.length} —Å–µ–≥–º–µ–Ω—Ç–æ–≤</div>`;

            segments.forEach((segment, index) => {
                const segmentDiv = document.createElement('div');
                segmentDiv.className = 'segment';
                segmentDiv.dataset.index = index;

                segmentDiv.innerHTML = `
                    <div>
                        <span class="timestamp-editable" title="–ö–ª–∏–∫–Ω–∏—Ç–µ –¥–ª—è –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è">
                            ‚è±Ô∏è <span class="time-start" contenteditable="true">${secondsToTime(segment.start)}</span>
                            ‚Äì
                            <span class="time-end" contenteditable="true">${secondsToTime(segment.end)}</span>
                            <button class="segment-btn merge-btn" title="–û–±—ä–µ–¥–∏–Ω–∏—Ç—å —Å–æ —Å–ª–µ–¥—É—é—â–∏–º">üîó</button>
                            <button class="segment-btn delete-btn" title="–£–¥–∞–ª–∏—Ç—å —Å–µ–≥–º–µ–Ω—Ç">üóëÔ∏è</button>
                            <button class="segment-btn split-btn" title="–†–∞–∑–¥–µ–ª–∏—Ç—å —Å–µ–≥–º–µ–Ω—Ç">‚úÇÔ∏è</button>
                        </span>
                        <div class="text-content" contenteditable="true">${segment.text || ''}</div>
                    </div>
                `;

                // –ù–∞–∑–Ω–∞—á–∞–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π
                const startTimeEl = segmentDiv.querySelector('.time-start');
                const endTimeEl = segmentDiv.querySelector('.time-end');
                const textEl = segmentDiv.querySelector('.text-content');
                const mergeBtn = segmentDiv.querySelector('.merge-btn');
                const deleteBtn = segmentDiv.querySelector('.delete-btn');
                const splitBtn = segmentDiv.querySelector('.split-btn');
                const timeContainer = segmentDiv.querySelector('.timestamp-editable');

                // –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏
                startTimeEl.addEventListener('input', (e) => {
                    updateSegmentTime(index, 'start', e.target.textContent);
                });

                endTimeEl.addEventListener('input', (e) => {
                    updateSegmentTime(index, 'end', e.target.textContent);
                });

                // –í–∞–ª–∏–¥–∞—Ü–∏—è –ø—Ä–∏ –ø–æ—Ç–µ—Ä–µ —Ñ–æ–∫—É—Å–∞
                startTimeEl.addEventListener('blur', () => {
                    validateTime(index, 'start', startTimeEl);
                });

                endTimeEl.addEventListener('blur', () => {
                    validateTime(index, 'end', endTimeEl);
                });

                // –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞
                textEl.addEventListener('input', (e) => {
                    updateSegmentText(index, e.target.textContent);
                });

                // –§–æ–∫—É—Å –Ω–∞ —Å–µ–≥–º–µ–Ω—Ç–µ
                textEl.addEventListener('focus', () => {
                    setActiveSegment(index);
                });

                // –ö–Ω–æ–ø–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
                mergeBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    mergeWithNext(index);
                });

                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    deleteSegment(index);
                });

                splitBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    splitSegment(index);
                });

                // –ö–ª–∏–∫ –ø–æ –≤—Ä–µ–º–µ–Ω–∏ –¥–ª—è –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è
                timeContainer.addEventListener('click', (e) => {
                    if (!e.target.classList.contains('segment-btn') &&
                        !e.target.classList.contains('time-start') &&
                        !e.target.classList.contains('time-end')) {
                        playSegment(index);
                    }
                });

                transcriptContainer.appendChild(segmentDiv);
            });

            if (currentSegmentIndex === -1 && segments.length > 0) {
                setActiveSegment(0);
            }
        }

        // ========== –§–£–ù–ö–¶–ò–ò –î–õ–Ø –†–ï–î–ê–ö–¢–ò–†–û–í–ê–ù–ò–Ø –¢–ê–ô–ú–ö–û–î–û–í ==========
        function updateSegmentTime(index, type, timeString) {
            if (!segments[index]) return;

            try {
                const timeParts = timeString.split(':');
                if (timeParts.length !== 3) return;

                const hours = parseInt(timeParts[0]) || 0;
                const minutes = parseInt(timeParts[1]) || 0;
                const seconds = parseInt(timeParts[2]) || 0;

                const totalSeconds = hours * 3600 + minutes * 60 + seconds;

                if (type === 'start') {
                    if (totalSeconds >= segments[index].end) {
                        segments[index].start = segments[index].end - 1;
                        return;
                    }
                    segments[index].start = totalSeconds;
                } else {
                    if (totalSeconds <= segments[index].start) {
                        segments[index].end = segments[index].start + 1;
                        return;
                    }
                    segments[index].end = totalSeconds;
                }
            } catch (e) {
                console.error('–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏:', e);
            }
        }

        function validateTime(index, type, element) {
            const timeString = element.textContent.trim();
            const timeRegex = /^(\d{1,2}):([0-5]\d):([0-5]\d)$/;

            if (!timeRegex.test(timeString)) {
                element.textContent = type === 'start'
                    ? secondsToTime(segments[index].start)
                    : secondsToTime(segments[index].end);
                showStatus('‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –≤—Ä–µ–º–µ–Ω–∏. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ß–ß:–ú–ú:–°–°', 'error');
            }
        }

        function mergeWithNext(index) {
            if (index >= segments.length - 1) {
                showStatus('‚ùå –ù–µ–ª—å–∑—è –æ–±—ä–µ–¥–∏–Ω–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω–∏–π —Å–µ–≥–º–µ–Ω—Ç', 'error');
                return;
            }

            const current = segments[index];
            const next = segments[index + 1];

            current.text = (current.text || '') + (current.text ? ' ' : '') + (next.text || '');
            current.end = next.end;

            segments.splice(index + 1, 1);

            if (currentSegmentIndex > index) currentSegmentIndex--;

            renderTranscript();
            showStatus('‚úÖ –°–µ–≥–º–µ–Ω—Ç—ã –æ–±—ä–µ–¥–∏–Ω–µ–Ω—ã', 'success');
        }

        function deleteSegment(index) {
            if (segments.length <= 1) {
                showStatus('‚ùå –ù–µ–ª—å–∑—è —É–¥–∞–ª–∏—Ç—å –ø–æ—Å–ª–µ–¥–Ω–∏–π —Å–µ–≥–º–µ–Ω—Ç', 'error');
                return;
            }

            if (confirm(`–£–¥–∞–ª–∏—Ç—å —Å–µ–≥–º–µ–Ω—Ç ${index + 1}?`)) {
                segments.splice(index, 1);

                if (currentSegmentIndex === index) {
                    currentSegmentIndex = Math.max(0, index - 1);
                } else if (currentSegmentIndex > index) {
                    currentSegmentIndex--;
                }

                renderTranscript();
                showStatus('‚úÖ –°–µ–≥–º–µ–Ω—Ç —É–¥–∞–ª–µ–Ω', 'success');
            }
        }

        function splitSegment(index) {
            const segment = segments[index];
            const midTime = Math.floor((segment.start + segment.end) / 2);
            const text = segment.text || '';
            const midText = Math.floor(text.length / 2);

            const newSegment = {
                start: midTime,
                end: segment.end,
                text: text.substring(midText)
            };

            segment.end = midTime;
            segment.text = text.substring(0, midText);

            segments.splice(index + 1, 0, newSegment);

            renderTranscript();
            showStatus('‚úÖ –°–µ–≥–º–µ–Ω—Ç —Ä–∞–∑–¥–µ–ª–µ–Ω –ø–æ–ø–æ–ª–∞–º', 'success');
        }

        function autoSplitLongSegments() {
            const maxDuration = 60; // —Å–µ–∫—É–Ω–¥
            let wasSplit = false;

            for (let i = segments.length - 1; i >= 0; i--) {
                const segment = segments[i];
                const duration = segment.end - segment.start;

                if (duration > maxDuration) {
                    const parts = Math.ceil(duration / maxDuration);
                    const partDuration = duration / parts;
                    const originalText = segment.text || '';

                    segments.splice(i, 1);

                    for (let p = 0; p < parts; p++) {
                        const newStart = segment.start + (p * partDuration);
                        const newEnd = segment.start + ((p + 1) * partDuration);

                        const textPart = originalText ?
                            originalText.substring(
                                Math.floor((p / parts) * originalText.length),
                                Math.floor(((p + 1) / parts) * originalText.length)
                            ) : '';

                        segments.splice(i + p, 0, {
                            start: newStart,
                            end: newEnd,
                            text: textPart.trim()
                        });
                    }

                    wasSplit = true;
                }
            }

            if (wasSplit) {
                renderTranscript();
                showStatus(`‚úÖ –î–ª–∏–Ω–Ω—ã–µ —Å–µ–≥–º–µ–Ω—Ç—ã —Ä–∞–∑–¥–µ–ª–µ–Ω—ã (–º–∞–∫—Å. ${maxDuration} —Å–µ–∫)`, 'success');
            } else {
                showStatus('‚úÖ –ù–µ—Ç –¥–ª–∏–Ω–Ω—ã—Ö —Å–µ–≥–º–µ–Ω—Ç–æ–≤ –¥–ª—è —Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è', 'success');
            }
        }

        // ========== –£–ü–†–ê–í–õ–ï–ù–ò–ï –ê–£–î–ò–û ==========
        function playSegment(index) {
            if (index < 0 || index >= segments.length) {
                showStatus('–°–µ–≥–º–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω', 'error');
                return;
            }

            setActiveSegment(index);

            const segment = segments[index];
            audio.currentTime = segment.start;

            audio.play().then(() => {
                showStatus(`üéµ –í–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ —Å ${secondsToTime(segment.start)}`, 'success');
            }).catch(e => {
                showStatus('‚ùå –û—à–∏–±–∫–∞ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è: ' + e.message, 'error');
                console.error('–û—à–∏–±–∫–∞ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è:', e);
            });

            const segmentElement = document.querySelector(`.segment[data-index="${index}"]`);
            if (segmentElement) {
                segmentElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        function setActiveSegment(index) {
            document.querySelectorAll('.segment').forEach(el => {
                el.classList.remove('active');
            });

            const segmentElement = document.querySelector(`.segment[data-index="${index}"]`);
            if (segmentElement) {
                segmentElement.classList.add('active');
            }

            currentSegmentIndex = index;
        }

        function playFromStart() {
            if (currentSegmentIndex >= 0) {
                playSegment(currentSegmentIndex);
            } else if (segments.length > 0) {
                playSegment(0);
            } else {
                audio.currentTime = 0;
                audio.play();
            }
        }

        function playPrev() {
            if (currentSegmentIndex > 0) {
                playSegment(currentSegmentIndex - 1);
            }
        }

        function playNext() {
            if (currentSegmentIndex < segments.length - 1) {
                playSegment(currentSegmentIndex + 1);
            }
        }

        function playSelected() {
            if (currentSegmentIndex >= 0) {
                playSegment(currentSegmentIndex);
            } else {
                playFromStart();
            }
        }

        function pauseAudio() {
            audio.pause();
        }

        function changeSpeed() {
            const rate = document.getElementById('playbackRate').value;
            audio.playbackRate = parseFloat(rate);
        }

        function showStatus(message, type) {
            statusDiv.innerHTML = `<div class="${type === 'error' ? 'error' : 'success'}">${message}</div>`;
            setTimeout(() => {
                if (statusDiv.innerHTML.includes(message)) {
                    statusDiv.innerHTML = '';
                }
            }, 3000);
        }

        // ========== –û–ë–ù–û–í–õ–ï–ù–ò–ï –î–ê–ù–ù–´–• ==========
        function parseAndRender() {
            const inputText = document.getElementById('transcriptInput').value;
            segments = parseTranscript(inputText);

            if (segments.length === 0) {
                alert('‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å —Å–µ–≥–º–µ–Ω—Ç—ã. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Ñ–æ—Ä–º–∞—Ç —Ç–∞–π–º–∫–æ–¥–æ–≤.');
                return;
            }

            renderTranscript();
            console.log(`–ó–∞–≥—Ä—É–∂–µ–Ω–æ ${segments.length} —Å–µ–≥–º–µ–Ω—Ç–æ–≤`, segments);
        }

        function updateSegmentText(index, text) {
            if (segments[index]) {
                segments[index].text = text;
            }
        }

        // ========== –≠–ö–°–ü–û–†–¢ ==========
        function exportJSON() {
            const dataStr = JSON.stringify(segments, null, 2);
            downloadFile(dataStr, 'edited_transcript.json', 'application/json');
            showStatus('‚úÖ JSON —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω', 'success');
        }

        function exportMarkdown() {
            let md = `# –¢—Ä–∞–Ω—Å–∫—Ä–∏–ø—Ü–∏—è –∞—É–¥–∏–æ\n\n`;
            md += `*–ê—É–¥–∏–æ—Ñ–∞–π–ª: ${audio.src || '–Ω–µ —É–∫–∞–∑–∞–Ω'}*\n`;
            md += `*–î–∞—Ç–∞ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è: ${new Date().toLocaleDateString()}*\n\n`;

            segments.forEach(segment => {
                const text = segment.text || '';
                const headerMatch = text.match(/^(#{1,6})\s+(.+?)(?:\n|$)/);

                if (headerMatch) {
                    const headerLevel = headerMatch[1];
                    const headerText = headerMatch[2];
                    const restOfText = text.substring(headerMatch[0].length).trim();

                    md += `${headerLevel} [${secondsToTime(segment.start)}] ${headerText}\n`;

                    if (restOfText) {
                        md += `${restOfText}\n`;
                    }
                } else {
                    md += `### [${secondsToTime(segment.start)}]\n`;
                    if (text) {
                        md += `${text}\n`;
                    }
                }
                md += `\n`;
            });

            downloadFile(md, 'transcript.md', 'text/markdown');
            showStatus('‚úÖ Markdown —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω', 'success');
        }

        function exportOriginalFormat() {
            let output = '';

            segments.forEach(segment => {
                const timecode = `${secondsToTime(segment.start)} ‚Äì ${secondsToTime(segment.end)}`;
                output += `${timecode}\n${segment.text || ''}\n\n`;
            });

            downloadFile(output, 'transcript.txt', 'text/plain');
            showStatus('‚úÖ –¢–µ–∫—Å—Ç —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω', 'success');
        }

        function exportSRT() {
            let srt = '';

            segments.forEach((segment, index) => {
                srt += `${index + 1}\n`;
                srt += `${secondsToSRTTime(segment.start)} --> ${secondsToSRTTime(segment.end)}\n`;
                srt += `${segment.text || ''}\n\n`;
            });

            downloadFile(srt, 'transcript.srt', 'text/plain');
            showStatus('‚úÖ –°—É–±—Ç–∏—Ç—Ä—ã (SRT) —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω—ã', 'success');
        }

        function secondsToSRTTime(seconds) {
            const hrs = Math.floor(seconds / 3600);
            const mins = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            const ms = Math.floor((seconds % 1) * 1000);
            return `${hrs.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')},${ms.toString().padStart(3, '0')}`;
        }

        function downloadFile(content, filename, type) {
            const blob = new Blob([content], { type });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // ========== –ó–ê–ì–†–£–ó–ö–ê –ê–£–î–ò–û ==========
        document.getElementById('audioUpload').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const url = URL.createObjectURL(file);
                audio.src = url;
                audio.load();
                showStatus(`‚úÖ –ê—É–¥–∏–æ –∑–∞–≥—Ä—É–∂–µ–Ω–æ: ${file.name}`, 'success');
                console.log(`–ó–∞–≥—Ä—É–∂–µ–Ω–æ –∞—É–¥–∏–æ: ${file.name}`);
            }
        });

        // Drag and drop –¥–ª—è –∞—É–¥–∏–æ
        const audioContainer = document.getElementById('audio-container');
        audioContainer.addEventListener('dragover', (e) => {
            e.preventDefault();
            audioContainer.style.backgroundColor = '#e8f4f8';
        });

        audioContainer.addEventListener('dragleave', () => {
            audioContainer.style.backgroundColor = '';
        });

        audioContainer.addEventListener('drop', (e) => {
            e.preventDefault();
            audioContainer.style.backgroundColor = '';

            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('audio/')) {
                const url = URL.createObjectURL(file);
                audio.src = url;
                audio.load();
                showStatus(`‚úÖ –ê—É–¥–∏–æ –∑–∞–≥—Ä—É–∂–µ–Ω–æ (–ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ–º): ${file.name}`, 'success');
                console.log(`–ü–µ—Ä–µ—Ç–∞—â–µ–Ω–æ –∞—É–¥–∏–æ: ${file.name}`);
            }
        });

        // –ê–≤—Ç–æ–≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ —Å–ª–µ–¥—É—é—â–µ–≥–æ —Å–µ–≥–º–µ–Ω—Ç–∞
        audio.addEventListener('timeupdate', () => {
            if (!segments.length) return;

            for (let i = 0; i < segments.length; i++) {
                if (audio.currentTime >= segments[i].start &&
                    audio.currentTime <= segments[i].end) {
                    if (currentSegmentIndex !== i) {
                        setActiveSegment(i);
                    }
                    break;
                }
            }
        });

        // –ê–≤—Ç–æ–∑–∞–≥—Ä—É–∑–∫–∞ –ø—Ä–∏–º–µ—Ä–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ
        window.onload = function() {
            parseAndRender();
        };
    </script>
</body>
</html>